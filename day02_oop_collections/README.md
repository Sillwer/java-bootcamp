# Основы Java - день 01 
## ООП / Java Коллекции

# Содержание:
1. [Упражнение 00 — Модели](#упражнение-00--модели)
2. [Упражнение 01 – Генератор ИД](#упражнение-01--генератор-ид)
3. [Упражнение 02 – Список пользователей](#упражнение-02--список-пользователей)
4. [Упражнение 03 — Список транзакций](#упражнение-03--список-транзакций)
5. [Упражнение 04 – Бизнес логика](#упражнение-04--бизнес-логика)
6. [Упражнение 05 — Меню](#упражнение-05--меню)

Каждый класс должен соответствовать принципам SOLID:
1. Принцип единственной ответственности: класс содержит одну логически связанную функциональность (кофемашина не может очищать стек вызовов и отслеживать изменения в нём; её предназначение — варить кофе).
2. Принцип открытости-закрытости: каждый класс может предоставлять возможность расширения своей функциональности. Однако такое расширение не должно требовать изменения исходного кода класса.
3. Принцип подстановки Лисков: производные классы лишь дополняют функциональность исходного класса, не изменяя его.
4. Принцип разделения интерфейсов: существует множество точек (интерфейсов), описывающих логически связанное поведение. Интерфейсов общего назначения не существует.
5. Принцип инверсии зависимостей: система не должна зависеть от конкретных сущностей; все зависимости основаны на абстракциях (интерфейсах).

Сегодня вам следует сосредоточиться на первом принципе SOLID.

### Основные правила
- Использовать версию Java 1.8.
- Соблюдать форматирование кода, основываясь на стандартах Oracle.
- Использовать "System.out" для вывода.

### Правила дня:
- Задачи оформлять в отдельные каталоги 'ex**00**, ex**01**, ...', подставляя номер задачи.

### Введение к заданиям дня
Внутренняя система денежных переводов является неотъемлемой частью многих бизнес-приложений.

Сегодняшняя задача — автоматизировать бизнес-процесс, связанный с переводами определённых сумм между участниками нашей системы.

Каждый пользователь системы может перевести определённую сумму денег другому пользователю. Нам необходимо убедиться, что даже если мы потеряем историю входящих и исходящих переводов конкретного пользователя, мы сможем восстановить эту информацию.

В системе все денежные транзакции хранятся в виде пар дебет/кредит. Например, Джон перевёл 500 долларов Майку. Система хранит транзакцию для обоих пользователей:
```java
John -> Mike, -500, OUTCOME, transaction ID
Mike -> John, +500, INCOME, transaction ID
```
Для восстановления связи внутри таких пар следует использовать идентификаторы каждой транзакции.


В такой сложной системе запись о переводе может быть утеряна — она может быть не зафиксирована для одного из пользователей (чтобы симулировать и отладить такую ​​ситуацию, разработчик должен иметь возможность удалить данные о переводе для одного из пользователей индивидуально). Поскольку такие ситуации реальны, необходима функциональность для отображения всех «неподтвержденных переводов» (транзакций, зарегистрированных только для одного пользователя) и решения таких проблем.

Ниже приведен ряд упражнений, которые можно выполнять по одному, чтобы решить задачу.

### Упражнение 00 — Модели
**Примечание:**
- Реализовать решение в файлах: User.java, Transaction.java, Program.java
- Доступно использование пользовательских классов, а так же: Integer, String, UUID, enumerations


Первая задача — разработать базовые модели предметной области, а именно, классы пользователей и транзакций.

Вполне вероятно, что разные пользователи в системе будут иметь одинаковые имена. Эту проблему можно решить, добавив специальное поле для уникального идентификатора пользователя. Этот идентификатор может быть любым целым числом. Конкретная логика создания идентификатора описана в следующем упражнении.

Таким образом, для класса User характерен следующий набор состояний (полей):
- Identifier,
- User name,
- Balance.


Класс Transaction описывает денежный перевод между двумя пользователями. Здесь также необходимо определить уникальный идентификатор. Поскольку количество таких транзакций может быть очень большим, мы определяем идентификатор как строку UUID. Таким образом, для класса Transaction характерен следующий набор состояний (полей):
- Identifier,
- Recipient (user type),
- Sender (user type),
- Transfer category (debit, credit),
- Transfer amount.

Необходимо проверить начальный баланс пользователя (он не может быть отрицательным), а также баланс для исходящих (только отрицательные суммы) и входящих (только положительные суммы) транзакций (использование методов get/set).

Пример использования таких классов должен быть включен в файл программы (создание, инициализация, вывод содержимого объекта на консоль). Все данные для полей класса должны быть жестко прописаны в программе.

### Упражнение 01 – Генератор ИД
**Примечание:**
- Реализовать решение в файлах: UserIdsGenerator.java, User.java, Program.java
- Можно использовать все разрешения из предыдущего упражнения.

Убедитесь, что каждый идентификатор пользователя уникален. Для этого создайте класс UserIdsGenerator. Поведение объекта этого класса определяет функционал генерации идентификаторов пользователей.

Современные системы управления базами данных поддерживают принцип автоинкремента, где каждый новый идентификатор представляет собой значение ранее сгенерированного идентификатора +1.\
Таким образом, класс UserIdsGenerator содержит последний сгенерированный идентификатор в качестве своего состояния. Поведение UserIdsGenerator определяется методом int generateId(), который возвращает новый сгенерированный идентификатор при каждом вызове.

Пример использования таких классов содержится в файле программы (создание, инициализация, вывод содержимого объекта на консоль).

**Примечание**:
- Убедитесь, что существует только один объект UserIdsGenerator (см. шаблон Singleton). Это необходимо, поскольку существование нескольких объектов этого класса не гарантирует уникальность всех идентификаторов пользователей..

- Идентификатор пользователя должен быть доступен только для чтения, поскольку он инициализируется только один раз (при создании объекта) и не может быть изменен позднее во время выполнения программы.

- В конструктор класса User следует добавить временную логику инициализации идентификатора:
```java
public User(...) {
	this.id = UserIdsGenerator.getInstance().generateId();
}
```

### Упражнение 02 – Список пользователей
**Примечание:**
- Реализовать решение в файлах: UsersList.java, UsersArrayList.java, User.java,Program.java, etc.
- throw
- Можно использовать все разрешения из предыдущего упражнения.

Теперь нам нужно реализовать функционал для сохранения пользователей во время работы программы.

В настоящее время ваше приложение не использует постоянное хранилище (например, файловую систему или базу данных). Однако мы хотим избежать зависимости вашей логики от способа реализации хранилища пользователей. Для большей гибкости мы определяем интерфейс UsersList, который описывает следующее поведение:

- Add a user;
- Get a user by ID;
- Get a user by index;
- Get number of users.

Этот интерфейс позволит вам разработать бизнес-логику вашего приложения таким образом, чтобы конкретная реализация хранилища не влияла на другие компоненты системы.

Мы также реализуем класс UsersArrayList, реализующий интерфейс UsersList.

Этот класс будет использовать массив для хранения пользовательских данных. Размер массива по умолчанию равен 10. При заполнении массива его размер увеличивается вдвое. Метод user-add помещает объект типа User в первую пустую ячейку массива.

При попытке извлечь пользователя с несуществующим идентификатором должно быть сгенерировано непроверяемое исключение UserNotFoundException.

Пример использования таких классов (создание, инициализация, вывод содержимого объекта на консоль) приведён в файле программы.

**Примечание**:
Класс Java `ArrayList<T>` имеет такую ​​же структуру. Самостоятельно моделируя поведение этого класса, вы научитесь использовать механизмы этого класса стандартной библиотеки.

### Упражнение 03 — Список транзакций
**Примечание:**
- Реализовать решение в файлах: TransactionsList.java, TransactionsLinkedList.java, User.java, Program.java, etc.
- Можно использовать все разрешения из предыдущего упражнения.

В отличие от пользователей, список транзакций требует особого подхода к реализации. Поскольку количество операций создания транзакций может быть очень большим, необходим метод хранения, позволяющий избежать дорогостоящего расширения размера массива.

В этом задании мы предлагаем вам создать интерфейс TransactionsList, описывающий следующее поведение:
- Add a transaction;
- Remove a transaction by ID (in this case, UUID string identifier is used);
- Transform into array (ex. Transaction[] toArray()).

Список транзакций должен быть реализован как связанный список (LinkedList) в классе TransactionsLinkedList. Таким образом, каждая транзакция должна содержать поле со ссылкой на объект следующей транзакции.
При попытке удалить транзакцию с несуществующим идентификатором должно быть сгенерировано исключение времени выполнения TransactionNotFoundException.
Пример использования таких классов должен быть приведён в файле программы (создание, инициализация, вывод содержимого объекта на консоль).

**Примечание**:
- Необходимо добавить поле типа TransactionsList в класс User, чтобы каждый пользователь мог хранить список своих транзакций.
- Транзакция должна быть добавлена ​​ОДНОЙ операцией (O(1)).
- Класс Java `LinkedList<T>` имеет ту же структуру: двунаправленный связанный список.

### Упражнение 04 – Бизнес логика
**Примечание**:
- Реализовать решение в файлах: TransactionsService.java, Program.java, etc.
- Можно использовать все разрешения из предыдущего упражнения.

Уровень бизнес-логики приложения располагается в сервисных классах. Такие классы содержат базовые системные алгоритмы, автоматизированные процессы и т. д. Эти классы обычно проектируются по шаблону «фасад», который может инкапсулировать поведение нескольких классов.

В этом случае класс TransactionsService должен содержать поле типа UserList для взаимодействия с пользователем и предоставлять следующую функциональность:
- Add a user;
- Get a user's balance.
- Perform a transfer transaction (user IDs and transfer amount are specified). In this case, two transactions of type DEBIT/CREDIT are created and added to the receiver and sender. The IDs of both transactions must be the same;
- Get transfers of a specific user (an ARRAY of transfers is returned). Remove a transaction by ID for a specific user (transaction ID and user ID are specified);
- Validate transactions (returns an ARRAY of unpaired transactions).

При попытке перевести сумму, превышающую остаток на балансе пользователя, должно быть сгенерировано исключение времени выполнения IllegalTransactionException.

Пример использования таких классов приведён в файле программы (создание, инициализация, вывод содержимого объекта на консоль).

### Упражнение 05 — Меню
**Примечание**:
- Реализовать решение в файлах: Menu.java, Program.java, etc.
- Можно использовать все разрешения из предыдущего упражнения.
- try/catch

В результате должно получиться работающее приложение с консольным меню. Функциональность меню должна быть реализована в соответствующем классе с полем-ссылкой на TransactionsService.

Каждый пункт меню должен сопровождаться номером команды, которую пользователь вводит для вызова действия.

Приложение должно поддерживать два режима запуска — production (режим по умолчанию) и dev (в котором информация о переводах для конкретного пользователя может быть удалена по его идентификатору, а также может быть выполнена функция проверки корректности всех переводов).

В случае возникновения исключения выводится сообщение об ошибке, и пользователю предоставляется возможность ввести корректные данные.

Сценарий работы приложения следующий (программа должна внимательно следовать этому примеру вывода):

```
$ java Program --profile=dev

1. Add a user
2. View user balances
3. Perform a transfer
4. View all transactions for a specific user
5. DEV – remove a transfer by ID
6. DEV – check transfer validity
7. Finish execution
-> 1
Enter a user name and a balance
-> Jonh 777
User with id = 1 is added
---------------------------------------------------------
1. Add a user
2. View user balances
3. Perform a transfer
4. View all transactions for a specific user
5. DEV – remove a transfer by ID
6. DEV – check transfer validity
7. Finish execution
-> 1
Enter a user name and a balance
-> Mike 100
User with id = 2 is added
---------------------------------------------------------
1. Add a user
2. View user balances
3. Perform a transfer
4. View all transactions for a specific user
5. DEV – remove a transfer by ID
6. DEV – check transfer validity
7. Finish execution
-> 3
Enter a sender ID, a recipient ID, and a transfer amount
-> 1 2 100
The transfer is completed
---------------------------------------------------------
1. Add a user
2. View user balances
3. Perform a transfer
4. View all transactions for a specific user
5. DEV – remove a transfer by ID
6. DEV – check transfer validity
7. Finish execution
-> 3
Enter a sender ID, a recipient ID, and a transfer amount
-> 1 2 150
The transfer is completed
---------------------------------------------------------
1. Add a user
2. View user balances
3. Perform a transfer
4. View all transactions for a specific user
5. DEV – remove a transfer by ID
6. DEV – check transfer validity
7. Finish execution
-> 3
Enter a sender ID, a recipient ID, and a transfer amount
-> 1 2 50
The transfer is completed
---------------------------------------------------------
1. Add a user
2. View user balances
3. Perform a transfer
4. View all transactions for a specific user
5. DEV – remove a transfer by ID
6. DEV – check transfer validity
7. Finish execution
-> 2
Enter a user ID
-> 2
Mike - 400
---------------------------------------------------------
1. Add a user
2. View user balances
3. Perform a transfer
4. View all transactions for a specific user
5. DEV – remove a transfer by ID
6. DEV – check transfer validity
7. Finish execution
-> 4
Enter a user ID
-> 1
To Mike(id = 2) -100 with id = cc128842-2e5c-4cca-a44c-7829f53fc31f
To Mike(id = 2) -150 with id = 1fc852e7-914f-4bfd-913d-0313aab1ed99
TO Mike(id = 2) -50 with id = ce183f49-5be9-4513-bd05-8bd82214eaba
---------------------------------------------------------
1. Add a user
2. View user balances
3. Perform a transfer
4. View all transactions for a specific user
5. DEV – remove a transfer by ID
6. DEV – check transfer validity
7. Finish execution
-> 5
Enter a user ID and a transfer ID
-> 1 1fc852e7-914f-4bfd-913d-0313aab1ed99
Transfer To Mike(id = 2) 150 removed
---------------------------------------------------------
1. Add a user
2. View user balances
3. Perform a transfer
4. View all transactions for a specific user
5. DEV – remove a transfer by ID
6. DEV – check transfer validity
7. Finish execution
-> 6
Check results:
Mike(id = 2) has an unacknowledged transfer id = 1fc852e7-914f-4bfd-913d-0313aab1ed99 from John(id = 1) for 150
```
